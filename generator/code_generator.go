package generator

import (
	"bytes"
	"fmt"
	"os"
	"text/template"
)

// PkgNameSetter is an interface that can set the package name.
type PkgNameSetter interface {
	// SetPkgName sets the package name of the receiver to the given value.
	//
	// Parameters:
	//   - pkg_name: The package name to set.
	//
	// Returns:
	//   - error: Returns an error if the receiver is nil.
	SetPkgName(pkg_name string) error
}

// CodeGenerator is a template-based code generator.
type CodeGenerator[T PkgNameSetter] struct {
	// sign is the signature of the code generator. (i.e., the command + flags used to invoke it)
	sign string

	// t is the template used to generate the code.
	t *template.Template
}

// New creates a new instance of CodeGenerator with a parsed template.
//
// Parameters:
//   - name: The name of the template.
//   - templ: The template string to be parsed.
//
// Returns:
//   - *CodeGenerator[T]: A pointer to the newly created CodeGenerator.
//   - error: An error if the template parsing fails.
func New[T PkgNameSetter](name, templ string) (*CodeGenerator[T], error) {
	t, err := template.New(name).Parse(templ)
	if err != nil {
		return nil, err
	}

	return &CodeGenerator[T]{
		t: t,
	}, nil
}

// Must is a helper function that wraps a call to a function that returns (*CodeGenerator[T], error) and
// panics if the error is not nil or if the CodeGenerator is nil.
//
// This function is intended to be used to handle errors in a way that is easy to read and write.
//
// Example usage:
//
//	cg = Must(NewCodeGenerator("example", "package {{.PkgName}}\n\nfunc Example() { ... }"))
func Must[T PkgNameSetter](cg *CodeGenerator[T], err error) *CodeGenerator[T] {
	if err != nil {
		panic(err)
	} else if cg == nil {
		panic(fmt.Errorf("cg must not be nil"))
	}

	return cg
}

// Generate generates code into the given location with the given data.
//
// Parameters:
//   - can_edit: If true, the generated code will have a comment indicating that it can be edited.
//   - sign: The signature of the code generator.
//   - loc: The location to write the generated code to.
//   - data: The data to pass to the template.
//
// Returns:
//   - error: An error if the template execution fails or if writing the file fails.
func (c CodeGenerator[T]) Generate(can_edit bool, sign, loc string, data T) error {
	pkg_name, err := GetPkgName(loc)
	if err != nil {
		return err
	}

	err = data.SetPkgName(pkg_name)
	if err != nil {
		return err
	}

	var buff bytes.Buffer

	if can_edit {
		_, err = fmt.Fprintf(&buff, "// Code generated by %q.\n\n", sign)
		if err != nil {
			return err
		}
	} else {
		_, err = fmt.Fprintf(&buff, "// Code generated by %q; DO NOT EDIT.\n\n", sign)
		if err != nil {
			return err
		}
	}

	err = c.t.Execute(&buff, data)
	if err != nil {
		return err
	}

	err = os.WriteFile(loc, buff.Bytes(), 0644)
	return err
}
